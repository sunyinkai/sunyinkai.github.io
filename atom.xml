<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NaOH&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-24T15:33:22.090Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>NaOH</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>how to use hexo</title>
    <link href="http://yoursite.com/2018/12/24/usage/"/>
    <id>http://yoursite.com/2018/12/24/usage/</id>
    <published>2018-12-24T15:08:01.000Z</published>
    <updated>2018-12-24T15:33:22.090Z</updated>
    
    <content type="html"><![CDATA[<p>hello,hexo</p>]]></content>
    
    <summary type="html">
    
      this is digest
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络流专题</title>
    <link href="http://yoursite.com/2018/03/31/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B8%93%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/31/网络流专题/</id>
    <published>2018-03-31T08:54:08.000Z</published>
    <updated>2018-03-31T16:00:31.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><p>问题:给你一幅网络图,每条边上有最大流量限制,问从源点s到汇点t的最大流量.</p><ul><li>增广路: 从源点s到汇点t的一条变权都为正的路径.</li><li>反向弧: 用于纠正错误的寻找增广路的一种机制,也就是给一个后悔的机会.其实这个东西,有种偷梁换柱的感觉.</li></ul><p><strong>FF算法</strong></p><p>Ford_Fulkerson算法(FF算法)就是基于这两个做的,不停的利用反向弧寻找增广路,复杂度$O(F\times E)$,F为最大流的流量,因为最坏情况下每次最大流量增加1,每次dfs寻找增广路复杂度为$O(E)$.</p><p><strong>Dinic算法</strong></p><ul><li>层次图: 就是从源点bfs,到节点u,距离为d[u],我们把d[u]叫做u的层次.</li><li>阻塞流:多次增广后,层次图中不存在由s-&gt;t的路径.</li></ul><p>算法由bfs求层次图,dfs求增广路组成.</p><p>引入层次图是<strong>防止盲目搜索,只做一次dfs,就求出这次层次图的所有增广路.</strong></p><p>复杂度为$O(V^2 \times E)$</p><p><a href="../link/dinic.cpp">dinic</a></p><p>参考:</p><p><a href="https://www.cnblogs.com/ZJUT-jiangnan/p/3632525.html" target="_blank" rel="noopener">江南的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最大流&quot;&gt;&lt;a href=&quot;#最大流&quot; class=&quot;headerlink&quot; title=&quot;最大流&quot;&gt;&lt;/a&gt;最大流&lt;/h3&gt;&lt;p&gt;问题:给你一幅网络图,每条边上有最大流量限制,问从源点s到汇点t的最大流量.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增广路: 从源点s到汇点t的
      
    
    </summary>
    
    
      <category term="专题" scheme="http://yoursite.com/tags/%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>codevs1288 埃及分数问题 迭代加深</title>
    <link href="http://yoursite.com/2018/03/30/codevs1288-%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0%E9%97%AE%E9%A2%98-%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1/"/>
    <id>http://yoursite.com/2018/03/30/codevs1288-埃及分数问题-迭代加深/</id>
    <published>2018-03-30T15:31:05.000Z</published>
    <updated>2018-03-30T15:58:23.242Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个真分数,问它最少能拆成几个单位分数的和,如果有多组解,选择最小分数最大的那组.</p><p>19/45=1/3 + 1/12 + 1/180</p><p> 19/45=1/3 + 1/15 + 1/45 </p><p>19/45=1/3 + 1/18 + 1/30,</p><p> 19/45=1/4 + 1/6 + 1/180</p><p> 19/45=1/5 + 1/6 + 1/18</p><p>所以最后答案为5,6,18.</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>早就听说了IDA*,一直没学.</p><p>这个算是第一道IDA*题.</p><p><strong>IDA*给我的感觉就是每次限制了搜索层数的dfs</strong>,先搜索第i层,如果没有解,那么就继续搜索第i+1层,这样一直做下去.这个的感觉有点像bfs,但是它省空间啊.</p><p>随着深度增加,搜索空间的大小指数增加,IDA*在递归深度限制的过程中虽然重复搜索了很多状态,但总的访问状态数和最后一次所访问的状态数还是同一数量级的.</p><p><strong>IDA*适用于搜索树很大,但答案所在深度不深的题目</strong></p><p>大体框架就是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(dfs(<span class="number">0</span>,<span class="number">0</span>,res)==INF)res++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br></pre></td></tr></table></figure><p>我们让分母值单调增加,对于这个题的一个减枝就是,如果使用cnt个单位分数让他们的值$\ge \frac{a}{b}$,那么 $\frac{cnt}{x}  \geq \frac{a}{b}$</p><p>那么$x \leq \frac{cnt\times b}{a}$</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a,b,tot;</span><br><span class="line"><span class="keyword">bool</span> hasAns;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line">LL ans[<span class="number">100</span>],res[<span class="number">100</span>];</span><br><span class="line">LL minFenmu;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> dep,LL fenzi,LL fenmu,LL prev)</span></span>&#123;<span class="comment">//prev单调递增</span></span><br><span class="line"><span class="keyword">if</span>(now&gt;=dep)<span class="keyword">return</span> ;</span><br><span class="line">LL limit=max(fenmu/fenzi,prev+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(LL i=limit;i&lt;=<span class="built_in">ceil</span>((<span class="keyword">double</span>)fenmu*(dep-now)/fenzi);++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;minFenmu)<span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(fenmu&gt;i*fenzi)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fenmu==i*fenzi)&#123;</span><br><span class="line">hasAns=<span class="literal">true</span>;</span><br><span class="line">ans[tot++]=i;</span><br><span class="line"><span class="keyword">if</span>(i&lt;res[tot<span class="number">-1</span>])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tot;++k)&#123;</span><br><span class="line">res[k]=ans[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">minFenmu=min(minFenmu,i);<span class="comment">//已经得到的解的最小分母的值,用于剪枝</span></span><br><span class="line">--tot;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">LL aa=fenzi*i-fenmu;</span><br><span class="line">LL bb=fenmu*i;</span><br><span class="line">LL GCD=gcd(aa,bb);</span><br><span class="line">ans[tot++]=i;</span><br><span class="line">dfs(now+<span class="number">1</span>,dep,aa/GCD,bb/GCD,i);</span><br><span class="line">tot--;<span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">hasAns=<span class="literal">false</span>;</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line">minFenmu=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;++i)res[i]=INF;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">dfs(<span class="number">0</span>,k,a,b,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(hasAns)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld "</span>,res[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给你一个真分数,问它最少能拆成几个单位分数的和,如果有多组解,选择最小分数最大的那组.&lt;/p&gt;
&lt;p&gt;19/45=1/3 + 1/12 + 
      
    
    </summary>
    
    
      <category term="搜索" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="IDA*" scheme="http://yoursite.com/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>连通分量专题</title>
    <link href="http://yoursite.com/2018/03/23/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E4%B8%93%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/23/连通分量专题/</id>
    <published>2018-03-22T16:21:02.000Z</published>
    <updated>2018-03-22T17:10:45.297Z</updated>
    
    <content type="html"><![CDATA[<p>在连通分量这一节中,主要包括:</p><p><strong>无向图的割点和点双连通分量,桥和边双连通分量,有向图的强连通分量</strong></p><p>其中,主要利用到的是两个数组:</p><p>low[u]:u以及他的后代所能回到的最小的dfn值.</p><p> dfn[u]:u点的访问时间.</p><h5 id="无向图的割点和点双连通分量"><a href="#无向图的割点和点双连通分量" class="headerlink" title="无向图的割点和点双连通分量"></a>无向图的割点和点双连通分量</h5><p>割点定义: 如果删除一个点后,连通块数量增加,该点为割点.</p><p>判定条件: 如果一个点为割点,需要满足low[u]$\geq$dfn[v],<strong>而如果u为根节点需要满足他的儿子需要$child\geq$2.</strong></p><p>代码: <a href="../link/割点.cpp">割点</a></p><p>点双连通分量定义: 子图中任意两个点之间至少存在两条”<strong>点不重复</strong>“的路径.</p><p>判定条件:没写过</p><p>代码:没写过</p><h5 id="无向图的桥和边双连通分量"><a href="#无向图的桥和边双连通分量" class="headerlink" title="无向图的桥和边双连通分量"></a>无向图的桥和边双连通分量</h5><p>桥的定义: 如果删除一条边后,连通块数量增加,该边为割边.</p><p>判定条件: v的后代只能连回v自己,既 $low[v]&gt;dfn[u]$. <strong>桥特别要注意重边,为了去重边,我们传边的编号.</strong></p><p>代码: <a href="../link/桥.cpp">桥</a></p><p>边双连通分量定义: 子图中任意两点之间至少存在两条”<strong>边不重复</strong>“的路径.</p><p>求解方法: 一个图中,把所有的桥去掉,每个连通分量对应着原图中的一个边双连通分量.</p><p>代码: <a href="../link/加最少边让图双连通.cpp">加最少的边,让整个图变成边双连通</a></p><p><strong>hint</strong></p><ul><li><strong>边双连通分量常伴随着缩点,然后得到一树,树上每个节点都是一个边双连通分量,树上的每条边都是桥.</strong></li></ul><h5 id="有向图的强连通分量"><a href="#有向图的强连通分量" class="headerlink" title="有向图的强连通分量"></a>有向图的强连通分量</h5><p>强连通分量的定义: 一个强连通分量内,任意两个点之间互相可达.</p><p>判定条件:  如果$low[u]==dfn[u]$,那么u点为该强连通分量的”根”</p><p>代码: <a href="../link/加最少边让有向图强连通.cpp">加最少的边让有向图强连通</a>  <strong>注意特判连通分量为1的情况</strong></p><p><strong>hint</strong></p><ul><li><strong>对于一个有向图,我们都可以考虑一下缩点,因为缩点后是一棵有向树,对有向树操作,我们就可以很方便的求DAG上的最长路等等,树具有非常优美的性质,无向图也是同理.</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在连通分量这一节中,主要包括:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无向图的割点和点双连通分量,桥和边双连通分量,有向图的强连通分量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中,主要利用到的是两个数组:&lt;/p&gt;
&lt;p&gt;low[u]:u以及他的后代所能回到的最小的dfn值.&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="专题" scheme="http://yoursite.com/tags/%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HDOJ6180 Schedule 前缀和+瞎搞+输入挂</title>
    <link href="http://yoursite.com/2018/03/17/HDOJ6180-Schedule-%E5%89%8D%E7%BC%80%E5%92%8C-%E7%9E%8E%E6%90%9E-%E8%BE%93%E5%85%A5%E6%8C%82/"/>
    <id>http://yoursite.com/2018/03/17/HDOJ6180-Schedule-前缀和-瞎搞-输入挂/</id>
    <published>2018-03-16T16:09:56.000Z</published>
    <updated>2018-03-16T16:30:06.601Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给出个加工任务的开始时间和结束时间，问最少要用多少台机器可以完成这些任务，同一台机器上的任务时间不能有重叠，但允许守尾相接。对于每组用例，输出两个整数，分别表示最少用的机器台数和所有机器用的总时间。一台机器的用时为它最后的结束时间减它最开始启动的时间，中间不会停机。</p><p>$ T (1 &lt;= T &lt;= 100) , N (0 &lt; N &lt;= 100000,0&lt;=s_i&lt;e_i&lt;=1e9)$</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">1 3//记住是左闭右开</span><br><span class="line">4 6</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 8</span><br></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这个题第一问是很简单,就是最大重叠数,用前缀和就可以解决了.对于第二个问,我们只需要考虑在哪些地方一定需要增加一台机器,把这个时间记录下来,一共记为$\sum first_i$,同理从后往前,可以算出$\sum last_i$,两个相减就可以了.</p><p>然后这个题的$s_i,t_i$都很大,所有我们需要离散化一下,采用 <strong>sort+unique+unordered_map</strong>的方法</p><p>最后但也是最重要的,数据规模很大,需要采用<strong>读入挂</strong>,T到怀疑人生,以后注意,<strong>如果超过1e6个数就采用读入挂</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUF_SIZE=<span class="number">409600</span>;</span><br><span class="line"><span class="keyword">int</span> sum[MAXN];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">int</span> l[MAXN],r[MAXN],a[MAXN];</span><br><span class="line"><span class="keyword">int</span> fp[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cur, eof;</span><br><span class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">next_char</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == BUF_SIZE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eof) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> bytes = fread(buf, <span class="number">1</span>, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">            <span class="keyword">if</span> (bytes &lt; BUF_SIZE) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buf + bytes, <span class="number">-1</span>, BUF_SIZE - bytes);</span><br><span class="line">                buf[bytes] = <span class="number">-1</span>;</span><br><span class="line">                eof = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf[cur++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next_int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = next_char();</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ch = next_char();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            x = x*<span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = next_char();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; IO = &#123;BUF_SIZE,&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T=IO.next_int();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">mp.clear();</span><br><span class="line"><span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line"><span class="built_in">memset</span>(fp,<span class="number">0</span>,<span class="keyword">sizeof</span>(fp));</span><br><span class="line"><span class="keyword">int</span> N=IO.next_int();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">l[i]=IO.next_int();</span><br><span class="line">r[i]=IO.next_int();</span><br><span class="line">--r[i];</span><br><span class="line">a[i]=l[i];a[N+i]=r[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(a,a+<span class="number">2</span>*N);<span class="comment">//离散化</span></span><br><span class="line"><span class="keyword">int</span> cnt=unique(a,a+<span class="number">2</span>*N)-a;</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;++i)&#123;</span><br><span class="line">mp[a[i]]=tot;</span><br><span class="line">fp[tot]=a[i];</span><br><span class="line">++tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> x=l[i],y=r[i];</span><br><span class="line">++sum[mp[l[i]]];--sum[mp[r[i]]+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> first=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;++i)&#123;</span><br><span class="line">sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(sum[i]&gt;ans)&#123;</span><br><span class="line">first+=fp[i]*(sum[i]-ans);</span><br><span class="line">ans=sum[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,ans);</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=tot;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum[i]&gt;ans)&#123;</span><br><span class="line">last+=(fp[i]+<span class="number">1</span>)*(sum[i]-ans);<span class="comment">//sum[i]-ans为突变的个数</span></span><br><span class="line">ans=sum[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,last-first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给出个加工任务的开始时间和结束时间，问最少要用多少台机器可以完成这些任务，同一台机器上的任务时间不能有重叠，但允许守尾相接。对于每组用例，输
      
    
    </summary>
    
    
      <category term="前缀和" scheme="http://yoursite.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="瞎搞" scheme="http://yoursite.com/tags/%E7%9E%8E%E6%90%9E/"/>
    
      <category term="离散化" scheme="http://yoursite.com/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>soj4554 Boring Game HASH</title>
    <link href="http://yoursite.com/2018/03/16/soj4554-Boring-Game-HASH/"/>
    <id>http://yoursite.com/2018/03/16/soj4554-Boring-Game-HASH/</id>
    <published>2018-03-15T16:02:07.000Z</published>
    <updated>2018-03-15T16:24:00.811Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个N*M的矩阵,($a_{ij} \leq NM$)接下来有$1e5$次询问,$x_1,y_1,x_2,y_2$分别为子矩阵左上右下的点,问这个子矩阵中是否$1到size(子矩阵)$这些数都在这个矩阵中出现一次.</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>我们可以采用hash的方法.</p><p>首先hash要满足可计算.</p><p>我们如果知道子矩阵的size,那么这个子矩阵中 所有数的和,所有数的平方的和,所有数立方的和等等信息,都可以知道了.那么我们需要先预处理一下原来矩阵中的信息.</p><p>记$sum[k][i][j]$为[1,i]*[1,j]矩阵中,每个数的k次方的和.那么有</p><p>预处理:</p><ul><li>$sum[k][i][j]=sum[k][i-1][j]+sum[k][i][j-1]-sum[k][i-1][j-1]+a[k][i][j]$</li></ul><p>询问: </p><ul><li>$sum[k][x_1..x_2][y_1..y_2]=sum[k][x_2][y_2]+sum[k][x_1-1][y_1-1]-sum[x_1-1][y_1]-sum[x_2][y_1-1]$</li></ul><p>这个题开始我hash了5次,但其实只要hash一次,hash一个数的三次方就行了.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line">uint f[maxn][maxn], g[maxn * maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(uint i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++)</span><br><span class="line">        g[i] = g[i<span class="number">-1</span>] + i * i * i;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%u"</span>, &amp;f[i][j]);</span><br><span class="line">                f[i][j] = f[i][j] * f[i][j] * f[i][j] + f[i<span class="number">-1</span>][j] + f[i][j<span class="number">-1</span>] - f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; q; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">            uint val = f[x2][y2] - f[x1<span class="number">-1</span>][y2] - f[x2][y1<span class="number">-1</span>] + f[x1<span class="number">-1</span>][y1<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, val == g[(x2-x1+<span class="number">1</span>)*(y2-y1+<span class="number">1</span>)] ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给你一个N*M的矩阵,($a_{ij} \leq NM$)接下来有$1e5$次询问,$x_1,y_1,x_2,y_2$分别为子矩阵左上右下的
      
    
    </summary>
    
    
      <category term="hash" scheme="http://yoursite.com/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>CF949A Zebras 瞎搞+set维护</title>
    <link href="http://yoursite.com/2018/03/12/CF949A-Zebras-%E7%9E%8E%E6%90%9E-set%E7%BB%B4%E6%8A%A4/"/>
    <id>http://yoursite.com/2018/03/12/CF949A-Zebras-瞎搞-set维护/</id>
    <published>2018-03-11T16:28:33.000Z</published>
    <updated>2018-03-11T16:43:44.072Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给你一个长度为$200000$的串,让你把这个串分为若干子序列,每个子序列必须为0,1交替出现,比如0,010,01010,等.且原串中每个字符一定属于且属于一个子序列.</p><p>比如0010100,我们可以把它分为3个子序列.</p><p>长度为3,分别为1,3,4号下标</p><p>长度为3,分别为2,5,6号下标</p><p>长度为1,分别为7号下标</p><p>否则,如果找不到就输出-1.</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>首先答案一定是$cnt[0]-cnt[1]$个,因为那种子序列0的个数永远比1的个数多1,故多出了多少个0,就是最后答案.</p><p>我们从左往右交替找0,1就好啦,如果最后一个元素不为0,那么就无解.</p><p>那么我们怎么快速找到还没有利用的0或者1的下标呢?可以考虑用<strong>set</strong>维护下标,然后每次lower_bound求出下一个下标,这样一直做就可以了.</p><p><strong>感觉维护那种只执行1次或者少量几次的下标的话,用set维护真的挺好的</strong></p><p><strong>比如以前做的补图最短路,补图强联通块计数,set维护还有哪些点没被访问过</strong></p><p><strong>再比如以前做的一个操作让一个数变为它的因子个数的数,用set维护哪些点还可以操作</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;st0,st2;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;G[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)st0.insert(i),cnt[<span class="number">0</span>]++;</span><br><span class="line"><span class="keyword">else</span> st2.insert(i),cnt[<span class="number">1</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt[<span class="number">0</span>]-cnt[<span class="number">1</span>]&lt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q[MAXN],tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> hasAns=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(cnt[<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> val=<span class="number">-1</span>;</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">auto</span> first=st0.lower_bound(val);</span><br><span class="line"><span class="keyword">if</span>(first==st0.end())&#123;</span><br><span class="line">hasAns=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">val=*first;</span><br><span class="line"><span class="comment">//printf("val=%d\n",val);</span></span><br><span class="line">cnt[<span class="number">0</span>]--;</span><br><span class="line">q[tot++]=val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> second=st2.lower_bound(val);</span><br><span class="line"><span class="keyword">if</span>(second==st2.end())&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">val=*second;</span><br><span class="line">cnt[<span class="number">1</span>]--;</span><br><span class="line">q[tot++]=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!hasAns)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)st0.erase(q[i]);</span><br><span class="line"><span class="keyword">else</span> st2.erase(q[i]);</span><br><span class="line">G[now].push_back(q[i]);</span><br><span class="line">&#125;</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt[<span class="number">1</span>]!=<span class="number">0</span>)hasAns=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!hasAns)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,now);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;now;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> len=G[i].size();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;++j)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,G[i][j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h4&gt;&lt;p&gt;给你一个长度为$200000$的串,让你把这个串分为若干子序列,每个子序列必须为0,1交替出现,比如0,010,01010,等.且原串中每个
      
    
    </summary>
    
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="瞎搞" scheme="http://yoursite.com/tags/%E7%9E%8E%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>CF948C Producing Snow 前缀和+二分</title>
    <link href="http://yoursite.com/2018/03/12/CF948C-Producing-Snow-%E5%89%8D%E7%BC%80%E5%92%8C-%E4%BA%8C%E5%88%86/"/>
    <id>http://yoursite.com/2018/03/12/CF948C-Producing-Snow-前缀和-二分/</id>
    <published>2018-03-11T16:07:14.000Z</published>
    <updated>2018-03-11T16:21:27.933Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Alice likes snow a lot! Unfortunately, this year’s winter is already over, and she can’t expect to have any more of it. Bob has thus bought her a gift — a large snow maker. He plans to make some amount of snow every day. On day <em>i</em> he will make a pile of snow of volume $V_i$ and put it in her garden.</p><p>Each day, every pile will shrink a little due to melting. More precisely, when the temperature on a given day is $T_i$, each pile will reduce its volume by $T_i$. If this would reduce the volume of a pile to or below zero, it disappears forever. All snow piles are independent of each other.</p><p>Note that the pile made on day <em>i</em> already loses part of its volume on the same day. In an extreme case, this may mean that there are no piles left at the end of a particular day.</p><p>You are given the initial pile sizes and the temperature on each day. Determine the total volume of snow melted on each day.</p><p>$N \leq 10^9,V_i \leq 10^9 ,T_i \leq10^9$</p><p>Output a single line with <em>N</em> integers, where the <em>i</em>-th integer represents the total volume of snow melted on day <em>i</em>.</p><p>每天堆一个雪人,如果当天温度为T,那么所有存在的雪人体积减少$min(T,V_{remain})$,问每一天融化的雪的体积数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in:                                       out:</span><br><span class="line">3                                 5 12 4</span><br><span class="line">10 10 5                         </span><br><span class="line">5 7 2</span><br></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>我们很自然有这样一个思路,考虑每个雪人能完整的撑过哪几天,然后再加上那个不完整的那天.</p><p>每天融化的雪量= k*$V_i$+$extra_i$</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tag[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  extra[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  V[MAXN],T[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;<span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;V[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T[i];</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+T[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> t=V[i];</span><br><span class="line"><span class="keyword">int</span> id=upper_bound(sum+<span class="number">1</span>,sum+N+<span class="number">1</span>,t+sum[i<span class="number">-1</span>])-sum;</span><br><span class="line">tag[i]++;tag[id]--;</span><br><span class="line">extra[id]+=t-(sum[id<span class="number">-1</span>]-sum[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">tag[i]+=tag[i<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tag[i]*T[i]+extra[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;Alice likes snow a lot! Unfortunately, this year’s winter is already o
      
    
    </summary>
    
    
      <category term="前缀和" scheme="http://yoursite.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>LightOJ1060 nth Permutaiton 计数的思想</title>
    <link href="http://yoursite.com/2018/03/10/LightOJ1060-nth-Permutaiton-%E8%AE%A1%E6%95%B0%E7%9A%84%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2018/03/10/LightOJ1060-nth-Permutaiton-计数的思想/</id>
    <published>2018-03-10T12:06:47.000Z</published>
    <updated>2018-03-10T12:39:53.336Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Given a string of characters, we can permute the individual characters to make new strings. At first we order the string into alphabetical order. Then we start permuting it.</p><p>For example the string <strong>‘abba’</strong> gives rise to the following 6 distinct permutations in alphabetical order.</p><p><strong>aabb 1</strong></p><p><strong>abab 2</strong></p><p><strong>abba 3</strong></p><p><strong>baab 4</strong></p><p><strong>baba 5</strong></p><p><strong>bbaa 6</strong></p><p>Given a string, you have to find the <strong>nth</strong> permutation for that string. For the above case <strong>‘aabb’</strong> is the 1st and <strong>‘baab’</strong> is the 4th permutation.</p><p>Input starts with an integer <strong>T (≤ 200)</strong>, denoting the number of test cases.</p><p>Each case contains a non empty string of lowercase letters with length no more than <strong>20</strong> and an integer <strong>n (0 &lt; n &lt; $2^{31}$)</strong>.</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>我们有逆康拓展开的思想,就是说,求长度为n的第k的一个排列(n从0开始).</p><p>比如说求长度为4的第5大的排列.</p><ul><li>先考虑第一个数,如果为1,那么能确定这个排列一定比 $0X3!=0$个数大,如果为2的话,那么可以确定,这个排列一定比$1X3!=6$个数大所以<strong>第一位应该填1,然后求剩余3位数中第5大的排列</strong>.</li><li>考虑第二个数,按照上面分析,那么这<strong>该位应该为4,然后求剩余2位数中排第1大的数</strong></li><li>那么最后的排列应该为:1432</li></ul><p>那么这个题可以利用同样的思想,只不过要考虑要去重的问题,方法就是</p><p>​    <strong>如果当前为x,那么我们就计算有多少个排列一定比它小,这样一直做下去就得到了答案</strong></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">500</span>],sum[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  fac[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;++i)fac[i]=fac[i<span class="number">-1</span>]*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> ch)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="string">'a'</span>;i&lt;=<span class="string">'z'</span>;++i)&#123;</span><br><span class="line">sum+=cnt[i];</span><br><span class="line">x[i]=cnt[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="string">'a'</span>;i&lt;ch;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!x[i])<span class="keyword">continue</span>;<span class="comment">//如果当前位选择i,会导致多少比他小(全排列的值)</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tmp=fac[sum<span class="number">-1</span>];</span><br><span class="line">x[i]--;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="string">'a'</span>;i&lt;=<span class="string">'z'</span>;++i)&#123;</span><br><span class="line">tmp/=fac[x[i]];</span><br><span class="line">&#125;</span><br><span class="line">res+=tmp;</span><br><span class="line">x[i]++;<span class="comment">//还原x[i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(id==len)&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="string">'0'</span>,bigX=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="string">'a'</span>;i&lt;=<span class="string">'z'</span>;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!cnt[i])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x=calc(i);</span><br><span class="line"><span class="keyword">if</span>(x&lt;=n)&#123;</span><br><span class="line">ans=i;</span><br><span class="line">bigX=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,ans);</span><br><span class="line">n-=bigX;</span><br><span class="line">cnt[ans]--;</span><br><span class="line">dfs(id+<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> test=<span class="number">1</span>;test&lt;=T;++test)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%lld"</span>,s,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: "</span>,test);</span><br><span class="line">len=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)cnt[s[i]]++;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxN=fac[len];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="string">'a'</span>;i&lt;=<span class="string">'z'</span>;++i)maxN/=fac[cnt[i]];</span><br><span class="line"><span class="keyword">if</span>(n&gt;maxN)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">n--;<span class="comment">//为了从0开始计数</span></span><br><span class="line">dfs(<span class="number">0</span>,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;Given a string of characters, we can permute the individual characters
      
    
    </summary>
    
    
      <category term="计数思想" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0%E6%80%9D%E6%83%B3/"/>
    
      <category term="康托展开" scheme="http://yoursite.com/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>LightOJ1057 Collecting Gold 旅行商问题</title>
    <link href="http://yoursite.com/2018/03/03/LightOJ1057-Collecting-Gold-%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/03/LightOJ1057-Collecting-Gold-旅行商问题/</id>
    <published>2018-03-03T05:57:30.000Z</published>
    <updated>2018-03-03T06:13:19.205Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Finally you found the city of Gold. As you are fond of gold, you start collecting them. But there are so much gold that you are getting tired collecting them.</p><p>So, you want to find the minimum effort to collect all the gold.</p><p>You can describe the city as a <strong>2D</strong> grid, where your initial position is marked by an <strong>‘x’</strong>. An empty place will be denoted by a <strong>‘.’</strong>. And the cells which contain gold will be denoted by <strong>‘g’</strong>. In each move you can go to all <strong>8</strong> adjacent places inside the city.</p><p>问从x出发收集完所有黄金并回到x至少需要走多少步,每步可以选择8个方向中的一个.</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>因为要从x出发,然后回到x,不难想到旅行商问题的方向.</p><p>然后就是构图,对我们有意义的是有g有x的点,我们可以把他们两两之间的距离算出来.这样就构成了一个完全图.</p><p><strong>从一个点到另一个点的距离为$max(|x_1-x_2|,|y_1-y_2|)$ </strong></p><p>旅行商问题复杂度$O(n^2*2^n)$</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a&lt;b?a:b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> cost[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> x[MAXN],y[MAXN],tot;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">1</span>&lt;&lt;<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;++j)&#123;</span><br><span class="line">            cost[i][j]=max(<span class="built_in">abs</span>(x[i]-x[j]),<span class="built_in">abs</span>(y[i]-y[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> S)</span></span>&#123;<span class="comment">//到达now点,有S个黄金的最小步数</span></span><br><span class="line">    <span class="keyword">if</span>(dp[now][S]&gt;=<span class="number">0</span>)<span class="keyword">return</span> dp[now][S];</span><br><span class="line"><span class="keyword">if</span>(now==<span class="number">0</span>&amp;&amp;S==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dp[now][S]=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="comment">//if(i==now)continue; 只有x没有g时,会出问题</span></span><br><span class="line">        <span class="keyword">if</span>((num&amp;S)&amp;&amp;S&gt;=num)&#123;</span><br><span class="line">            dp[now][S]=min(dp[now][S],dfs(i,S-num)+cost[i][now]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[now][S];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> test=<span class="number">1</span>;test&lt;=T;++test)&#123;</span><br><span class="line">        <span class="keyword">int</span> N,M;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i][j]==<span class="string">'g'</span>||s[i][j]==<span class="string">'x'</span>)&#123;</span><br><span class="line">                    x[tot]=i;</span><br><span class="line">                    y[tot++]=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,test,dfs(<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;tot)<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;Finally you found the city of Gold. As you are fond of gold, you start
      
    
    </summary>
    
    
      <category term="状压DP" scheme="http://yoursite.com/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="旅行商问题" scheme="http://yoursite.com/tags/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>CF846B 思维</title>
    <link href="http://yoursite.com/2018/03/01/CF846B-%E6%80%9D%E7%BB%B4/"/>
    <id>http://yoursite.com/2018/03/01/CF846B-思维/</id>
    <published>2018-03-01T03:55:28.000Z</published>
    <updated>2018-03-03T06:15:43.831Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>有n个任务,每个任务有相同的k个子任务,你可以按任何顺序完成子任务,每完成一个得1分,但如果你把一个任务的所有子任务都完成了,就可以额外的得到一分.每个子任务所需要的时间$ t_i \leq 10^6$, 你有M的时间,求你最多能得多少分.</p><p>$n \leq 45,k \leq 45, M \leq 2*10^9 $</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>问题的难点在于究竟要不要完成一个完整的任务.</p><p>比如说这样一组数据.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 4 17</span><br><span class="line">1 2 4 7</span><br></pre></td></tr></table></figure><p>如果我们选择完成一个完整的任务,可以获得7分,否则可以获得6分.</p><p><strong>难点在完成多少个完整的任务上,那么我们是不是就可以枚举这个东西呢,其他的当做不完成 完整的拿来贪心</strong></p><p>复杂度 $ O(n^2k)$</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">47</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> t[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,k,M;<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;k,&amp;M);</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),sum+=a[i];</span><br><span class="line">sort(a,a+k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;++j)</span><br><span class="line">t[i][j]=a[j];<span class="comment">//n row k col</span></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> full=<span class="number">0</span>;full&lt;=n;++full)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=M;</span><br><span class="line"><span class="keyword">int</span> res=full*(k+<span class="number">1</span>);</span><br><span class="line">tmp-=sum*full;<span class="comment">//the remain time</span></span><br><span class="line"><span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k<span class="number">-1</span>;++j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=full;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(tmp&gt;=t[i][j])tmp-=t[i][j],res++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">goto</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">flag:</span><br><span class="line"><span class="keyword">if</span>(res&gt;ans)&#123;</span><br><span class="line">ans=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h4&gt;&lt;p&gt;有n个任务,每个任务有相同的k个子任务,你可以按任何顺序完成子任务,每完成一个得1分,但如果你把一个任务的所有子任务都完成了,就可以额外的得
      
    
    </summary>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="思维" scheme="http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Race to 1 Again 期望</title>
    <link href="http://yoursite.com/2018/02/28/Race-to-1-Again-%E6%9C%9F%E6%9C%9B/"/>
    <id>http://yoursite.com/2018/02/28/Race-to-1-Again-期望/</id>
    <published>2018-02-27T16:20:42.000Z</published>
    <updated>2018-02-27T16:33:07.424Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Rimi learned a new thing about integers, which is - any positive integer greater than <strong>1</strong> can be divided by its divisors. So, he is now playing with this property. He selects a number <strong>N</strong>. And he calls this <strong>D</strong>.</p><p>In each turn he randomly chooses a divisor of <strong>D</strong> <strong>(1 to D)</strong>. Then he divides <strong>D</strong> by the number to obtain new <strong>D</strong>. He repeats this procedure until <strong>D</strong>becomes <strong>1</strong>. What is the expected number of moves required for <strong>N</strong> to become <strong>1</strong>.</p><p>大概就是说一个数每次除以他的因子,问这个数变为1的步数期望</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><strong>期望倒着推,概率正着推</strong></p><p>很有趣的一道题,和杭电上的飞行棋那题有点像.</p><p>很显然:ex[1]=0</p><p>然后我们考虑2: 2可以到达1,2,那么ex[2]=$\frac{1}{2} $ex[1]+$\frac{1}{2}$ex[2]+1.</p><p>因为2可以到达1或者2概率都为1/2,然后再加上这次所花费的步数1.</p><p>同理 ex[6]=$\frac{1}{4}$ex[1]+$\frac{1}{4}$ex[2]+$\frac{1}{4}$ex[3]+$\frac{1}{4}$ex[6]+1.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//感觉这种记忆化写法挺常见的,以前在区域赛写过一次,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">double</span> ex[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ex[x]&gt;<span class="number">0</span>)<span class="keyword">return</span> ex[x];</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> ex[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//printf("x=%d\n",x);</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">500</span>],top=<span class="number">0</span>,i;<span class="comment">//这个地方开始开的50,爆炸了</span></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i*i&lt;x;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">stack</span>[top++]=i;</span><br><span class="line"><span class="built_in">stack</span>[top++]=x/i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i*i==x)<span class="built_in">stack</span>[top++]=i;</span><br><span class="line"><span class="keyword">double</span> res=top;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;top;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">stack</span>[j]!=x)res+=dfs(<span class="built_in">stack</span>[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ex[x]=res*<span class="number">1.0</span>/(top<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> test=<span class="number">1</span>;test&lt;=T;++test)&#123;</span><br><span class="line"><span class="comment">//for(int x=1;x&lt;=100000;++x)&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="comment">//printf("x=%d\n",x);</span></span><br><span class="line">ex[<span class="number">1</span>]=<span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %.7f\n"</span>,test,dfs(x));</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;Rimi learned a new thing about integers, which is - any positive integ
      
    
    </summary>
    
    
      <category term="期望" scheme="http://yoursite.com/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>CF938D 多源最短路</title>
    <link href="http://yoursite.com/2018/02/27/CF938D_%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/02/27/CF938D_多源最短路/</id>
    <published>2018-02-27T13:34:49.000Z</published>
    <updated>2018-02-27T13:48:59.958Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你$N$个点, 有点权$a[i]$, 有$M$条边, 每条边有边权$c[i]$, 对于每个$i$ ,$j$ 为任意点,求$min(dist(i,j)*2+a[j])$</p><p>$N,M \leq 2*10^5$</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目相当于求每个点到图中的最短路,既多源最短路.可以利用堆优化的dijkstra求得.因为堆顶每次都为到改点的距离最小值,我们每次取出堆顶,然后向相邻点扩展即可.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INF=<span class="number">1e17</span>;</span><br><span class="line">priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt;q;</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt;G[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  cost[MAXN],d[MAXN];</span><br><span class="line"><span class="keyword">int</span> done[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N,M;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;<span class="keyword">long</span> <span class="keyword">long</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%I64d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">G[a].push_back(P(<span class="number">2</span>*c,b));</span><br><span class="line">G[b].push_back(P(<span class="number">2</span>*c,a));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;cost[i]);</span><br><span class="line">q.push(P(cost[i],i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)d[i]=INF,done[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">P p=q.top();q.pop();</span><br><span class="line"><span class="keyword">int</span> u=p.second;</span><br><span class="line"><span class="keyword">if</span>(done[u])<span class="keyword">continue</span>;</span><br><span class="line">done[u]=<span class="number">1</span>;</span><br><span class="line">d[u]=p.first;</span><br><span class="line"><span class="keyword">int</span> len=G[u].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> v=G[u][i].second;</span><br><span class="line">q.push(P(G[u][i].first+d[u],v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d "</span>,d[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给你$N$个点, 有点权$a[i]$, 有$M$条边, 每条边有边权$c[i]$, 对于每个$i$ ,$j$ 为任意点,求$min(dist
      
    
    </summary>
    
    
      <category term="CF CDE" scheme="http://yoursite.com/tags/CF-CDE/"/>
    
      <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CF891A Pride</title>
    <link href="http://yoursite.com/2018/02/23/CF891A/"/>
    <id>http://yoursite.com/2018/02/23/CF891A/</id>
    <published>2018-02-23T02:16:06.000Z</published>
    <updated>2018-02-23T02:25:10.404Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>A. Pride</p><p>You have an array <em>a</em> with length <em>n</em>, you can perform operations. Each operation is like this: choose two adjacent elements from <em>a</em>, say <em>x</em> and <em>y</em>, and replace one of them with <em>gcd</em>(<em>x</em>, <em>y</em>), where <em>gcd</em> denotes the <a href="https://en.wikipedia.org/wiki/Greatest_common_divisor" target="_blank" rel="noopener">greatest common divisor</a>.</p><p>What is the minimum number of operations you need to make all of the elements equal to 1?</p><p>Input</p><p>The first line of the input contains one integer <em>n</em> (1 ≤ <em>n</em> ≤ 2000) — the number of elements in the array.</p><p>The second line contains <em>n</em> space separated integers <em>a</em>1, <em>a</em>2, …, <em>an</em> (1 ≤ <em>ai</em> ≤ 109) — the elements of the array.</p><p>Output</p><p>Print -1, if it is impossible to turn all numbers to 1. Otherwise, print the minimum number of operations needed to make all numbers equal to 1.</p><p>Examples</p><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 2 3 4 6</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2 4 6 8</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p>Copy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 6 9</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><ul><li>如果有x个1,那么显然答案为n-x</li><li>如果没有1,考虑最少需要多少操作弄出一个1来,考虑到gcd(x,y)赋值给y更好,因为gcd(x,y)已经少了一些因子,然后问题就转化为求最短的区间使得gcd(L,R)为1.<strong>gcd(L,R+1)=gcd(gcd(L,R),a[R+1]))</strong>可以O(n^2)求出所有区间的gcd值.</li><li>另外这种枚举的方式我觉得挺妙的</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a&lt;b?a:b)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> cnt1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][i]);</span><br><span class="line"><span class="keyword">if</span>(a[i][i]==<span class="number">1</span>)++cnt1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt1!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n-cnt1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">a[i][j]=gcd(a[i][j<span class="number">-1</span>],a[j][j]);</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="number">1</span>)ans=min(ans,j-i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans==INF)<span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n<span class="number">-1</span>+ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;A. Pride&lt;/p&gt;
&lt;p&gt;You have an array &lt;em&gt;a&lt;/em&gt; with length &lt;em&gt;n&lt;/em&gt;, y
      
    
    </summary>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="思维" scheme="http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>CF938C</title>
    <link href="http://yoursite.com/2018/02/21/CF938C/"/>
    <id>http://yoursite.com/2018/02/21/CF938C/</id>
    <published>2018-02-21T09:57:23.000Z</published>
    <updated>2018-02-21T10:33:03.351Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Let’s denote a <em>m</em>-free matrix as a binary (that is, consisting of only 1’s and 0’s) matrix such that every square submatrix of size <em>m</em> × <em>m</em> of this matrix contains at least one zero.</p><p>Consider the following problem:</p><p>You are given two integers <em>n</em> and <em>m</em>. You have to construct an <em>m</em>-free square matrix of size <em>n</em> × <em>n</em> such that the number of 1’s in this matrix is maximum possible. Print the maximum possible number of 1’s in such matrix.</p><p>You don’t have to solve this problem. Instead, you have to construct a few tests for it.</p><p>You will be given <em>t</em> numbers <em>x</em>1, <em>x</em>2, …, $x_t$. For every <img src="http://codeforces.com/predownloaded/43/f1/43f1e11898ef657b1c1c02e1ae7b954c5230a2d9.png" alt="img">, find two integers <em>n</em> and <em>m</em> (<em>n</em> ≥ <em>m</em>) such that the answer for the aforementioned problem is exactly <em>x</em> .</p><p>Input</p><p>The first line contains one integer <em>t</em> (1 ≤ <em>t</em> ≤ 100) — the number of tests you have to construct.</p><p>Then <em>t</em> lines follow, <em>i</em>-th line containing one integer <em>x</em> (0 ≤ <em>x</em> ≤ $10^9$).</p><p>Output</p><p>For each test you have to construct, output two positive numbers <em>n</em> and <em>m</em> (1 ≤ <em>m</em>≤ <em>n</em> ≤ 10^9) such that the maximum number of 1’s in a <em>m</em>-free <em>n</em> × <em>n</em> matrix is exactly <em>x</em>. If there are multiple solutions, you may output any of them; and if this is impossible to construct a test, output a single integer  - 1.</p><p>Example</p><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">21</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 1</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>不难发现对于每一个子阵,总是最右下方的那个地方置为0最合适,因为这样的<strong>潜力</strong>最大.</p><p>问题转化为是否存在n,m使得$n^2$-$[n/m]^2$=x.</p><p>既是 $a^2-b^2=C $</p><p>转化一下 $ (a+b)(a-b)=C$</p><p>然后再分解因子搞一搞就可以了.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(((s+t)&amp;<span class="number">1</span>)||((s-t)&amp;<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">n=(s+t)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//printf("n=%d\n",n);</span></span><br><span class="line"><span class="keyword">if</span>(n&gt;INF||n&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> tmp=(s-t)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(n/i&lt;tmp||n/i&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n/i==tmp)&#123;</span><br><span class="line">m=i;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1 1\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> tag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=x;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>&amp;&amp;judge(i,x/i))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,n,m);</span><br><span class="line">tag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!tag)<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;Let’s denote a &lt;em&gt;m&lt;/em&gt;-free matrix as a binary (that is, consisting
      
    
    </summary>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="思维" scheme="http://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="CF CDE" scheme="http://yoursite.com/tags/CF-CDE/"/>
    
  </entry>
  
  <entry>
    <title>CF909E Coprocessor</title>
    <link href="http://yoursite.com/2018/02/11/CF909E/"/>
    <id>http://yoursite.com/2018/02/11/CF909E/</id>
    <published>2018-02-11T04:34:39.000Z</published>
    <updated>2018-02-11T09:09:18.231Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h4><p>You are given a program you want to execute as a set of tasks organized in a dependency graph. The dependency graph is a directed acyclic graph: each task can depend on results of one or several other tasks, and there are no directed circular dependencies between tasks. A task can only be executed if all tasks it depends on have already completed.</p><p>Some of the tasks in the graph can only be executed on a coprocessor, and the rest can only be executed on the main processor. In one coprocessor call you can send it a set of tasks which can only be executed on it. For each task of the set, all tasks on which it depends must be either already completed or be included in the set. The main processor starts the program execution and gets the results of tasks executed on the coprocessor automatically.</p><p>Find the minimal number of coprocessor calls which are necessary to execute the given program.</p><p>Input</p><p>The first line contains two space-separated integers <em>N</em> (1 ≤ <em>N</em> ≤ $10^5$) — the total number of tasks given, and <em>M</em> (0 ≤ <em>M</em> ≤ $10^5$) — the total number of dependencies between tasks.</p><p>The next line contains <em>N</em> space-separated integers <img src="http://codeforces.com/predownloaded/9b/23/9b230264d053f4d67fc85fa445cd108b8120528f.png" alt="img">. If $E_i​$= 0, task <em>i</em> can only be executed on the main processor, otherwise it can only be executed on the coprocessor.</p><p>The next <em>M</em> lines describe the dependencies between tasks. Each line contains two space-separated integers <em>T</em>1 and <em>T</em>2 and means that task <em>T</em>1 depends on task <em>T</em>2 (<em>T</em>1 ≠ <em>T</em>2). Tasks are indexed from 0 to <em>N</em> - 1. All <em>M</em> pairs (<em>T</em>1, <em>T</em>2) are distinct. It is guaranteed that there are no circular dependencies between tasks.</p><p>Output</p><p>Output one line containing an integer — the minimal number of coprocessor calls necessary to execute the program.</p><p>Examples</p><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">0 1 0 1</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 1 1 0</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">3 0</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>其实思路还是比较好想的,肯定是要从入度为0的点入手.</p><p><strong><del>solution 1</del></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们不难想到这样一个策略,从入度为0的点入手,如果当前处理的是0,那么res+1,否则一直继续.</span><br><span class="line">然后WA3.</span><br><span class="line">那么我们考虑这样一组数据:</span><br><span class="line">5 4</span><br><span class="line">1 1 0 1 0</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 3</span><br><span class="line">0 4</span><br><span class="line">显然不正确,原来是没有考虑顺序,我们先拿0,再拿1不就可以了么.</span><br></pre></td></tr></table></figure><p>  <strong><del>solution 2</del></strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">然后依然WA3.</span><br><span class="line">我们考虑这样一组数据:</span><br><span class="line">5 3</span><br><span class="line">0 1 0 1 0</span><br><span class="line">1 0</span><br><span class="line">2 1</span><br><span class="line">4 3</span><br><span class="line">也不正确</span><br></pre></td></tr></table></figure><p><strong>solution</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">我们维护两个入读为<span class="number">0</span>的队列分别存值为<span class="number">0</span>的点和值为<span class="number">1</span>的点,我们先把度为<span class="number">0</span>的点的队列拿光后,再把度为<span class="number">1</span>的点的队列中点拿光,这样一直做下去就可以了.</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1e5</span>+<span class="number">7</span>,MAXE=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;</span><br><span class="line">&#125;es[MAXE];</span><br><span class="line"><span class="keyword">int</span> head[MAXV],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">es[tot].to=b;</span><br><span class="line">es[tot].next=head[a];</span><br><span class="line">head[a]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num[MAXV],in[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> V,E;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;V,&amp;E);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;E;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">addEdge(b,a);</span><br><span class="line">in[a]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q1,q2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i]==<span class="number">0</span>)q1.push(i);</span><br><span class="line"><span class="keyword">else</span> q2.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=V;</span><br><span class="line"><span class="keyword">while</span>(cnt)&#123;</span><br><span class="line"><span class="keyword">while</span>(!q1.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> no=q1.front();q1.pop();</span><br><span class="line">--cnt;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[no];~i;i=es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=es[i].to;</span><br><span class="line">in[v]--;</span><br><span class="line"><span class="keyword">if</span>(in[v]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[v]==<span class="number">0</span>)q1.push(v);</span><br><span class="line"><span class="keyword">else</span> q2.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!q2.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> no=q2.front();q2.pop();</span><br><span class="line">--cnt;</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[no];~i;i=es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=es[i].to;</span><br><span class="line">in[v]--;</span><br><span class="line"><span class="keyword">if</span>(in[v]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[v]==<span class="number">0</span>)q1.push(v);</span><br><span class="line"><span class="keyword">else</span> q2.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)++res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目:&quot;&gt;&lt;/a&gt;题目:&lt;/h4&gt;&lt;p&gt;You are given a program you want to execute as a set of tasks organi
      
    
    </summary>
    
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="topo排序" scheme="http://yoursite.com/tags/topo%E6%8E%92%E5%BA%8F/"/>
    
      <category term="CF CDE" scheme="http://yoursite.com/tags/CF-CDE/"/>
    
  </entry>
  
</feed>
